From 6dddd6a825ec3b06405d77bdb2c22023e5f0ed01 Mon Sep 17 00:00:00 2001
From: arroway <stephanie@minet.net>
Date: Tue, 14 Jun 2011 00:13:42 +0200
Subject: [PATCH 01/11] virtio_blk_execute: l.242: enqueue again vbb in
 vbb_list if bad enqueue reserve

---
 blk/virtio-blk.c |   18 +++++++++++++++++-
 virtio.c         |    1 +
 2 files changed, 18 insertions(+), 1 deletions(-)

diff --git a/blk/virtio-blk.c b/blk/virtio-blk.c
index 928d66d..fcf16e9 100755
--- a/blk/virtio-blk.c
+++ b/blk/virtio-blk.c
@@ -199,6 +199,8 @@ virtio_blk_execute(struct virtio_blk_softc *sc)
 
 	r = virtio_enqueue_prep(vsc, vq, &slot);
 	if (r != 0) {
+		kprintf("%u slots\n", slot);
+		kprintf("virtio_blk_execute: no slot available in vq.\n We requeue.\n ");
 		/* We need to requeue this guy as there was no slot*/
 		spin_lock(&sc->vbb_queue_lock);
 		TAILQ_INSERT_TAIL(&sc->vbb_queue, vbb, vbb_list);
@@ -208,7 +210,7 @@ virtio_blk_execute(struct virtio_blk_softc *sc)
 	}
 
 	bio = vbb->bio;
-	kfree(vbb, M_DEVBUF);
+	//kfree(vbb, M_DEVBUF);
 	bp = bio->bio_buf;
 	vr = &sc->sc_reqs[slot];
 	isread= (bp->b_cmd & BUF_CMD_READ);
@@ -232,11 +234,20 @@ virtio_blk_execute(struct virtio_blk_softc *sc)
 		return r;
 	}
 
+	// pourquoi vr->nseg + 2 ?
 	r = virtio_enqueue_reserve(vsc, vq, slot, vr->nseg + 2);
 	if (r != 0) {
 		kprintf("Bad enqueue_reserve\n");
+
+		//we enqueue again vbb in vbb_list
+		spin_lock(&sc->vbb_queue_lock);
+		TAILQ_INSERT_TAIL(&sc->vbb_queue, vbb, vbb_list);
+		spin_unlock(&sc->vbb_queue_lock);
 		return r;
 	}
+
+	kfree(vbb, M_DEVBUF);
+
 	vr->vr_bp = bp;
 	vr->vr_hdr.type = isread?VIRTIO_BLK_T_IN:VIRTIO_BLK_T_OUT;
 	vr->vr_hdr.ioprio = 0;
@@ -290,6 +301,7 @@ virtio_disk_strategy(struct dev_strategy_args *ap)
 	TAILQ_INSERT_TAIL(&sc->vbb_queue, vbb, vbb_list);
 	spin_unlock(&sc->vbb_queue_lock);
 
+
 	virtio_blk_execute(sc);
 	return(0); 
 }
@@ -297,12 +309,16 @@ virtio_disk_strategy(struct dev_strategy_args *ap)
 static int
 virtio_disk_close(struct dev_close_args *ap)
 {
+
+	//decr cdev->usecount
+	//in detach: only unload if the counter is = 0
 	debug("%s\n", __FUNCTION__);
 	return 0;
 }
 static int
 virtio_disk_open(struct dev_open_args *ap)
 {
+	//incr cdev->usecount
 	debug("%s\n", __FUNCTION__);
 	return 0;
 }
diff --git a/virtio.c b/virtio.c
index 8088d86..07f65e2 100755
--- a/virtio.c
+++ b/virtio.c
@@ -395,6 +395,7 @@ vq_sync_descs(struct virtio_softc *sc, struct virtqueue *vq, int ops)
 static void
 vq_free_entry(struct virtqueue *vq, struct vq_entry *qe)
 {
+	kprintf("call of q_free_entry(): vq_num=%u", vq->vq_num);
 	spin_lock(&vq->vq_freelist_lock);
 	TAILQ_INSERT_TAIL(&vq->vq_freelist, qe, qe_list);
 	spin_unlock(&vq->vq_freelist_lock);
-- 
1.7.4.4

